# 1장. 깨끗한 코드(Clean Code)

```text
이 책을 읽고 나면...
- 코드에 대해 많은 사실을 알게 됨
- 좋은 코드와 나쁜 코드를 구분하는 방법
- 좋은 코드를 작성하는 방법
- 나쁜 코드를 좋은 코드로 바꾸는 실력
```

## 코드가 존재하리라

코드는 항상 존재한다.

## 나쁜 코드

**르블랑의 법칙(Leblanc's Law)** : 나중은 절대 오지 않는다.

## 나쁜 코드로 치르는 대가

나쁜 코드가 쌓일 수록 생산성은 낮아진다.

### 원대한 재설계의 꿈

망가진 코드 -> 재설계 -> (재설계 기간동안) 기존시스템의 변경 사항 반영 -> 길고 긴 경주

**깨끗한 코드를 만드는 노력이 비용을 절감할 뿐만 아니라 전문가로서 살아남는 길이다.**

### 태도

좋은 코드를 사수하는 일은 프로그래머들의 책임이다.

### 원초적 난제

기한을 맞추는 유일한 방법, 빨리 가는 유일한 방법은 **언제나 코드를 최대한 깨끗하게 유지하는 습관** 이다.

### 깨끗한 코드라는 예술?

**코드 감각**이 있으면, 좋은 코드와 나쁜 코드를 구분, 절제와 규율을 적용해 나쁜 코드를 좋은 코드로 바꾸는 전략도 파악한다.

### 께끗한 코드란?

#### 비야네 스트롭스트룹(C++ 창시자)

- '보기에 즐거운' 코드
- 효율적인 코드
- 세세한 사항까지 꼼꼼하게 처리하는 코드(철저한 오류 처리)
- 한가지에 '집중'하는 코드

#### 그래디 부치(Object Oriented Analysis and Design with Application 저자)

> 깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. 결코 설계자의 의도를 숨기지 않는다. 명쾌한 추상화와 단순한 제어문으로 가득하다.

- 잘 쓴 문장처럼 읽히는 코드
- '명쾌한' 추상화 : 코드는 추측이 아니라 사실에 기반

#### '큰(big)' 데이브 토마스(OTI 창립자, 이클립스 전략의 대부)

- 다른 사람이 고치기 쉽다
- 작을 수록 좋다. (의존성 최소)
- 테스트 케이스가 없는 코드는 깨끗한 코드가 아니다.
- 코드가 '문학적'이어야 한다 = 읽기 좋은 코드

#### 마이클 페더스(Working Effectively with Legacy Code 저자)

- 주의 깊게 작성한 코드
- 시간을 들여 단정하게 정리한 코드
- 세세한 사항까지 꼼꼼하게 신경쓴 코드

-> 주의를 기울인 코드

#### 론 제프리스(Extreme Programming Installed와 Extreme Programming Advanture in C# 저자)

- 중복을 피하라
- 한 기능만 수행하라
- 제대로 표현하라
- 작게 추상화 하라

#### 워드 커닝행(위키 창시자)

- 읽으면서 짐작한 대로 돌아가는 코드
- "코드가 그 문제를 풀기 위한 언어처럼 보인다면" 아름다운 코드

### 우리들 생각

- 깨끗한 변수 이름, 깨끗한 함수, 깨끗한 클래스를 만드는 방법을 소개
- **오브젝트 멘토 진영이 생각하는 깨끗한 코드**를 설명

### 우리는 저자다

새 코드를 짜는데 우리는 끊임없이 기존 코드를 읽는다. 읽는 시간이 현저히 많다.
-> 읽기 쉬운 코드가 매우 중요하다.

### 보이스카우트 규칙

> 캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라. *(미국 보이스카우트가 따르는 규칙)*

지속적인 개선은 전문가 정신의 본질이다.

### 프리퀄과 원칙

이 책은 Agile Software Development: Principles, Patterns, and Practices의 프리퀄(속편)이다.  
[아미존](https://www.amazon.com/Software-Development-Principles-Patterns-Practices/dp/0135974445)  
[교보문고 - 클린 소프트웨어 애자일 원칙과 패턴 그리고 실천방법](https://product.kyobobook.co.kr/detail/S000001875106)

앞으로 산발적으로 SRP, OCP, DIP 등에 대해서 거론한다.

```text
- SRP(Single Responsibility Principle): 클래스에는 한 가지, 단 한 가지 변경 이유만 존재해야 한다.
- OCP(Open Closed Principle): 클래스는 확장에 열려 있어야 하며 변경에 닫혀 있어야 한다.
- LSP(Liskov Substitution Principle): 상속받은 클래스는 기초 클래스를 대체할 수 있어야 한다.
- DIP(Dependency Inversion Principle): 추상화에 의존해야하며, 구체화에 의존하면 안 된다.
- ISP(Interface Segregation Principle): 클라이언트에 밀접하게 작게 쪼개진 인터페이스를 유지한다.
```

### 결론

"연습해! 연습"
